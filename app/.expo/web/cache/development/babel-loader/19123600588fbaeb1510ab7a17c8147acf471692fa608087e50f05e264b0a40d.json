{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\other\\\\PERSONAL PROJECTS\\\\pharmacy-tracker\\\\app\\\\node_modules\\\\react-native-maps\\\\src\\\\Geojson.tsx\";\nimport * as React from 'react';\nimport Marker from './MapMarker';\nimport Polyline from './MapPolyline';\nimport MapPolygon from './MapPolygon';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Geojson = props => {\n  const {\n    anchor,\n    centerOffset,\n    geojson,\n    strokeColor,\n    fillColor,\n    strokeWidth,\n    color,\n    title,\n    image,\n    zIndex,\n    onPress,\n    lineCap,\n    lineJoin,\n    tappable,\n    tracksViewChanges,\n    miterLimit,\n    lineDashPhase,\n    lineDashPattern,\n    markerComponent\n  } = props;\n  const pointOverlays = makePointOverlays(geojson.features);\n  const lineOverlays = makeLineOverlays(geojson.features);\n  const polygonOverlays = makePolygonOverlays(geojson.features);\n  return _jsxDEV(React.Fragment, {\n    children: [pointOverlays.map((overlay, index) => {\n      const markerColor = getColor(color, overlay, 'marker-color');\n      const pointOverlayTracksViewChanges = overlay.feature.properties?.tracksViewChanges || tracksViewChanges;\n      return _jsxDEV(Marker, {\n        coordinate: overlay.coordinates,\n        tracksViewChanges: pointOverlayTracksViewChanges,\n        image: image,\n        title: title,\n        pinColor: markerColor,\n        zIndex: zIndex,\n        anchor: anchor,\n        centerOffset: centerOffset,\n        onPress: () => onPress && onPress(overlay),\n        children: markerComponent\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 250,\n        columnNumber: 11\n      }, this);\n    }), lineOverlays.map((overlay, index) => {\n      const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _jsxDEV(Polyline, {\n        coordinates: overlay.coordinates,\n        strokeColor: lineStrokeColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        zIndex: zIndex,\n        tappable: tappable,\n        onPress: () => onPress && onPress(overlay)\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 270,\n        columnNumber: 11\n      }, this);\n    }), polygonOverlays.map((overlay, index) => {\n      const polygonFillColor = getColor(fillColor, overlay, 'fill');\n      const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _jsxDEV(MapPolygon, {\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: lineStrokeColor,\n        fillColor: polygonFillColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        tappable: tappable,\n        onPress: () => onPress && onPress(overlay),\n        zIndex: zIndex\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 11\n      }, this);\n    })]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 244,\n    columnNumber: 5\n  }, this);\n};\nexport default Geojson;\nconst makePointOverlays = features => {\n  return features.filter(isAnyPointFeature).map(feature => makeCoordinatesForAnyPoint(feature.geometry).map(coordinates => makeOverlayForAnyPoint(coordinates, feature))).reduce((prev, curr) => prev.concat(curr), []).map(overlay => Object.assign({}, overlay, {\n    type: 'point'\n  }));\n};\nconst makeLineOverlays = features => {\n  return features.filter(isAnyLineStringFeature).map(feature => makeCoordinatesForAnyLine(feature.geometry).map(coordinates => makeOverlayForAnyLine(coordinates, feature))).reduce((prev, curr) => prev.concat(curr), []).map(overlay => Object.assign({}, overlay, {\n    type: 'polyline'\n  }));\n};\nconst makePolygonOverlays = features => {\n  const multipolygons = features.filter(isMultiPolygonFeature).map(feature => makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates => makeOverlayForAnyPolygon(coordinates, feature))).reduce((prev, curr) => prev.concat(curr), []).map(overlay => Object.assign({}, overlay, {\n    type: 'polygon'\n  }));\n  const polygons = features.filter(isPolygonFeature).map(feature => makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature)).reduce((prev, curr) => prev.concat(curr), []).map(overlay => Object.assign({}, overlay, {\n    type: 'polygon'\n  }));\n  return polygons.concat(multipolygons);\n};\nconst makeOverlayForAnyPoint = (coordinates, feature) => {\n  return {\n    feature,\n    coordinates\n  };\n};\nconst makeOverlayForAnyLine = (coordinates, feature) => {\n  return {\n    feature,\n    coordinates\n  };\n};\nconst makeOverlayForAnyPolygon = (coordinates, feature) => {\n  return {\n    feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined\n  };\n};\nconst makePoint = c => ({\n  latitude: c[1],\n  longitude: c[0]\n});\nconst makeLine = l => l.map(makePoint);\nconst makeCoordinatesForAnyPoint = geometry => {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makePoint);\n};\nconst makeCoordinatesForAnyLine = geometry => {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForPolygon = geometry => {\n  return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForMultiPolygon = geometry => {\n  return geometry.coordinates.map(p => p.map(makeLine));\n};\nconst getRgbaFromHex = (hex, alpha = 1) => {\n  const matchArray = hex.match(/\\w\\w/g);\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n  const [r, g, b] = matchArray.map(x => {\n    const subColor = parseInt(x, 16);\n    if (Number.isNaN(subColor)) {\n      throw new Error('Invalid hex string');\n    }\n    return subColor;\n  });\n  return `rgba(${r},${g},${b},${alpha})`;\n};\nconst getColor = (prop, overlay, colorType) => {\n  if (prop) {\n    return prop;\n  }\n  let color = overlay.feature.properties?.[colorType];\n  if (color) {\n    const opacityProperty = colorType + '-opacity';\n    const alpha = overlay.feature.properties?.[opacityProperty];\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n    return color;\n  }\n  return undefined;\n};\nconst getStrokeWidth = (prop, overlay) => {\n  if (prop) {\n    return prop;\n  }\n  return overlay.feature.properties?.['stroke-width'];\n};\nconst isPointFeature = feature => feature.geometry.type === 'Point';\nconst isMultiPointFeature = feature => feature.geometry.type === 'MultiPoint';\nconst isAnyPointFeature = feature => isPointFeature(feature) || isMultiPointFeature(feature);\nconst isLineStringFeature = feature => feature.geometry.type === 'LineString';\nconst isMultiLineStringFeature = feature => feature.geometry.type === 'MultiLineString';\nconst isAnyLineStringFeature = feature => isLineStringFeature(feature) || isMultiLineStringFeature(feature);\nconst isPolygonFeature = feature => feature.geometry.type === 'Polygon';\nconst isMultiPolygonFeature = feature => feature.geometry.type === 'MultiPolygon';","map":{"version":3,"names":["React","Marker","Polyline","MapPolygon","jsxDEV","_jsxDEV","Geojson","props","anchor","centerOffset","geojson","strokeColor","fillColor","strokeWidth","color","title","image","zIndex","onPress","lineCap","lineJoin","tappable","tracksViewChanges","miterLimit","lineDashPhase","lineDashPattern","markerComponent","pointOverlays","makePointOverlays","features","lineOverlays","makeLineOverlays","polygonOverlays","makePolygonOverlays","Fragment","children","map","overlay","index","markerColor","getColor","pointOverlayTracksViewChanges","feature","properties","coordinate","coordinates","pinColor","fileName","_jsxFileName","lineNumber","columnNumber","lineStrokeColor","lineStrokeWidth","getStrokeWidth","polygonFillColor","holes","filter","isAnyPointFeature","makeCoordinatesForAnyPoint","geometry","makeOverlayForAnyPoint","reduce","prev","curr","concat","Object","assign","type","isAnyLineStringFeature","makeCoordinatesForAnyLine","makeOverlayForAnyLine","multipolygons","isMultiPolygonFeature","makeCoordinatesForMultiPolygon","makeOverlayForAnyPolygon","polygons","isPolygonFeature","makeCoordinatesForPolygon","length","slice","undefined","makePoint","c","latitude","longitude","makeLine","l","p","getRgbaFromHex","hex","alpha","matchArray","match","Error","r","g","b","x","subColor","parseInt","Number","isNaN","prop","colorType","opacityProperty","isPointFeature","isMultiPointFeature","isLineStringFeature","isMultiLineStringFeature"],"sources":["C:/Users/other/PERSONAL PROJECTS/pharmacy-tracker/app/node_modules/react-native-maps/src/Geojson.tsx"],"sourcesContent":["import * as React from 'react';\nimport type {\n  Feature,\n  FeatureCollection,\n  Point,\n  Position,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon,\n} from 'geojson';\nimport Marker, {type MapMarkerProps as MarkerProps} from './MapMarker';\nimport type {MapPolygonProps as PolygonProps} from './MapPolygon';\nimport type {MapPolylineProps as PolylineProps} from './MapPolyline';\nimport Polyline from './MapPolyline';\nimport MapPolygon from './MapPolygon';\nimport type {LatLng} from './sharedTypes';\n\nexport type GeojsonProps = {\n  /**\n   * Sets the anchor point for the marker.\n   * The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.\n   *\n   * The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0],\n   * where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner.\n   *\n   * The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding.\n   * For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).\n   *\n   * @default {x: 0.5, y: 1.0}\n   * @platform iOS: Google Maps only. For Apple Maps, see the `centerOffset` prop\n   * @platform Android: Supported\n   */\n  anchor?: MarkerProps['anchor'];\n\n  /**\n   * The offset (in points) at which to display the annotation view.\n   *\n   * By default, the center point of an annotation view is placed at the coordinate point of the associated annotation.\n   *\n   * Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.\n   *\n   * @default {x: 0.0, y: 0.0}\n   * @platform iOS: Apple Maps only. For Google Maps, see the `anchor` prop\n   * @platform Android: Not supported. See see the `anchor` prop\n   */\n  centerOffset?: MarkerProps['centerOffset'];\n\n  /**\n   * The pincolor used on markers\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  color?: MarkerProps['pinColor'];\n\n  /**\n   * The fill color to use for the path.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  fillColor?: PolygonProps['fillColor'];\n\n  /**\n   * [Geojson](https://geojson.org/) description of object.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  geojson: FeatureCollection;\n\n  /**\n   * A custom image to be used as the marker's icon. Only local image resources are allowed to be\n   * used.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  image?: MarkerProps['image'];\n\n  /**\n   * The line cap style to apply to the open ends of the path.\n   * The default style is `round`.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Supported\n   */\n  lineCap?: PolylineProps['lineCap'];\n\n  /**\n   * An array of numbers specifying the dash pattern to use for the path.\n   *\n   * The array contains one or more numbers that indicate the lengths (measured in points) of the\n   * line segments and gaps in the pattern. The values in the array alternate, starting with the\n   * first line segment length, followed by the first gap length, followed by the second line\n   * segment length, and so on.\n   *\n   * This property is set to `null` by default, which indicates no line dash pattern.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  lineDashPattern?:\n    | PolygonProps['lineDashPattern']\n    | PolylineProps['lineDashPattern'];\n\n  /**\n   * The offset (in points) at which to start drawing the dash pattern.\n   *\n   * Use this property to start drawing a dashed line partway through a segment or gap. For\n   * example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the\n   * middle of the first gap.\n   *\n   * The default value of this property is 0.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  lineDashPhase?: PolylineProps['lineDashPhase'];\n\n  /**\n   * The line join style to apply to corners of the path.\n   * The default style is `round`.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  lineJoin?: PolylineProps['lineJoin'];\n\n  /**\n   * Component to render in place of the default marker when the overlay type is a `point`\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  markerComponent?: MarkerProps['children'];\n\n  /**\n   * The limiting value that helps avoid spikes at junctions between connected line segments.\n   * The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If\n   * the ratio of the miter length—that is, the diagonal length of the miter join—to the line\n   * thickness exceeds the miter limit, the joint is converted to a bevel join. The default\n   * miter limit is 10, which results in the conversion of miters whose angle at the joint\n   * is less than 11 degrees.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  miterLimit?: PolylineProps['miterLimit'];\n\n  /**\n   * Callback that is called when the user presses any of the overlays\n   */\n  onPress?: (event: OverlayPressEvent) => void;\n\n  /**\n   * The stroke color to use for the path.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  strokeColor?: PolygonProps['strokeColor'] | PolylineProps['strokeColor'];\n\n  /**\n   * The stroke width to use for the path.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  strokeWidth?: PolygonProps['strokeWidth'] | PolylineProps['strokeWidth'];\n\n  /**\n   * Make the `Polygon` or `Polyline` tappable\n   *\n   * @platform — iOS: Google Maps only\n   * @platform — Android: Supported\n   */\n  tappable?: PolygonProps['tappable'] | PolylineProps['tappable'];\n\n  /**\n   * The title of the marker. This is only used if the <Marker /> component has no children that\n   * are a `<Callout />`, in which case the default callout behavior will be used, which\n   * will show both the `title` and the `description`, if provided.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  title?: MarkerProps['title'];\n\n  /**\n   * Sets whether this marker should track view changes.\n   * It's recommended to turn it off whenever it's possible to improve custom marker performance.\n   * This is the default value for all point markers in your geojson data. It can be overriden\n   * on a per point basis by adding a `trackViewChanges` property to the `properties` object on the point.\n   *\n   * @default true\n   * @platform iOS: Google Maps only\n   * @platform Android: Supported\n   */\n  tracksViewChanges?: boolean;\n\n  /**\n   * The order in which this tile overlay is drawn with respect to other overlays. An overlay\n   * with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays\n   * with the same z-index is arbitrary. The default zIndex is 0.\n   *\n   * @platform iOS: Apple Maps: [Marker], Google Maps: [Marker, Polygon, Polyline]\n   * @platform Android: Supported\n   */\n  zIndex?:\n    | MarkerProps['zIndex']\n    | PolygonProps['zIndex']\n    | PolylineProps['zIndex'];\n};\n\nconst Geojson = (props: GeojsonProps) => {\n  const {\n    anchor,\n    centerOffset,\n    geojson,\n    strokeColor,\n    fillColor,\n    strokeWidth,\n    color,\n    title,\n    image,\n    zIndex,\n    onPress,\n    lineCap,\n    lineJoin,\n    tappable,\n    tracksViewChanges,\n    miterLimit,\n    lineDashPhase,\n    lineDashPattern,\n    markerComponent,\n  } = props;\n  const pointOverlays = makePointOverlays(geojson.features);\n  const lineOverlays = makeLineOverlays(geojson.features);\n  const polygonOverlays = makePolygonOverlays(geojson.features);\n  return (\n    <React.Fragment>\n      {pointOverlays.map((overlay, index) => {\n        const markerColor = getColor(color, overlay, 'marker-color');\n        const pointOverlayTracksViewChanges =\n          overlay.feature.properties?.tracksViewChanges || tracksViewChanges;\n        return (\n          <Marker\n            key={index}\n            coordinate={overlay.coordinates}\n            tracksViewChanges={pointOverlayTracksViewChanges}\n            image={image}\n            title={title}\n            pinColor={markerColor}\n            zIndex={zIndex}\n            anchor={anchor}\n            centerOffset={centerOffset}\n            onPress={() => onPress && onPress(overlay)}>\n            {markerComponent}\n          </Marker>\n        );\n      })}\n      {lineOverlays.map((overlay, index) => {\n        const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n        const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n\n        return (\n          <Polyline\n            key={index}\n            coordinates={overlay.coordinates}\n            strokeColor={lineStrokeColor}\n            strokeWidth={lineStrokeWidth}\n            lineDashPhase={lineDashPhase}\n            lineDashPattern={lineDashPattern}\n            lineCap={lineCap}\n            lineJoin={lineJoin}\n            miterLimit={miterLimit}\n            zIndex={zIndex}\n            tappable={tappable}\n            onPress={() => onPress && onPress(overlay)}\n          />\n        );\n      })}\n      {polygonOverlays.map((overlay, index) => {\n        const polygonFillColor = getColor(fillColor, overlay, 'fill');\n        const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n        const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n\n        return (\n          <MapPolygon\n            key={index}\n            coordinates={overlay.coordinates}\n            holes={overlay.holes}\n            strokeColor={lineStrokeColor}\n            fillColor={polygonFillColor}\n            strokeWidth={lineStrokeWidth}\n            lineDashPhase={lineDashPhase}\n            lineDashPattern={lineDashPattern}\n            lineCap={lineCap}\n            lineJoin={lineJoin}\n            miterLimit={miterLimit}\n            tappable={tappable}\n            onPress={() => onPress && onPress(overlay)}\n            zIndex={zIndex}\n          />\n        );\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default Geojson;\n\nconst makePointOverlays = (features: Feature[]): AnyPointOverlay[] => {\n  return features\n    .filter(isAnyPointFeature)\n    .map(feature =>\n      makeCoordinatesForAnyPoint(feature.geometry).map(coordinates =>\n        makeOverlayForAnyPoint(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'point'}));\n};\n\nconst makeLineOverlays = (features: Feature[]): AnyLineStringOverlay[] => {\n  return features\n    .filter(isAnyLineStringFeature)\n    .map(feature =>\n      makeCoordinatesForAnyLine(feature.geometry).map(coordinates =>\n        makeOverlayForAnyLine(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'polyline'}));\n};\n\nconst makePolygonOverlays = (features: Feature[]): AnyPolygonOverlay[] => {\n  const multipolygons: AnyPolygonOverlay[] = features\n    .filter(isMultiPolygonFeature)\n    .map(feature =>\n      makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates =>\n        makeOverlayForAnyPolygon(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'polygon'}));\n\n  const polygons: AnyPolygonOverlay[] = features\n    .filter(isPolygonFeature)\n    .map(feature =>\n      makeOverlayForAnyPolygon(\n        makeCoordinatesForPolygon(feature.geometry),\n        feature,\n      ),\n    )\n    .reduce<Omit<AnyPolygonOverlay, 'type'>[]>(\n      (prev, curr) => prev.concat(curr),\n      [],\n    )\n    .map(overlay => ({...overlay, type: 'polygon'}));\n\n  return polygons.concat(multipolygons);\n};\n\nconst makeOverlayForAnyPoint = (\n  coordinates: LatLng,\n  feature: Feature<Point | MultiPoint>,\n): Omit<AnyPointOverlay, 'type'> => {\n  return {feature, coordinates};\n};\n\nconst makeOverlayForAnyLine = (\n  coordinates: LatLng[],\n  feature: Feature<LineString | MultiLineString>,\n): Omit<AnyLineStringOverlay, 'type'> => {\n  return {feature, coordinates};\n};\n\nconst makeOverlayForAnyPolygon = (\n  coordinates: LatLng[][],\n  feature: Feature<Polygon | MultiPolygon>,\n): Omit<AnyPolygonOverlay, 'type'> => {\n  return {\n    feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined,\n  };\n};\n\nconst makePoint = (c: Position): LatLng => ({\n  latitude: c[1],\n  longitude: c[0],\n});\n\nconst makeLine = (l: Position[]) => l.map(makePoint);\n\nconst makeCoordinatesForAnyPoint = (geometry: Point | MultiPoint) => {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makePoint);\n};\n\nconst makeCoordinatesForAnyLine = (geometry: LineString | MultiLineString) => {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makeLine);\n};\n\nconst makeCoordinatesForPolygon = (geometry: Polygon) => {\n  return geometry.coordinates.map(makeLine);\n};\n\nconst makeCoordinatesForMultiPolygon = (geometry: MultiPolygon) => {\n  return geometry.coordinates.map(p => p.map(makeLine));\n};\n\nconst getRgbaFromHex = (hex: string, alpha: number = 1) => {\n  const matchArray = hex.match(/\\w\\w/g);\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n  const [r, g, b] = matchArray.map(x => {\n    const subColor = parseInt(x, 16);\n    if (Number.isNaN(subColor)) {\n      throw new Error('Invalid hex string');\n    }\n    return subColor;\n  });\n  return `rgba(${r},${g},${b},${alpha})`;\n};\n\nconst getColor = (\n  prop: string | undefined,\n  overlay: Overlay,\n  colorType: string,\n) => {\n  if (prop) {\n    return prop;\n  }\n  let color = overlay.feature.properties?.[colorType];\n  if (color) {\n    const opacityProperty = colorType + '-opacity';\n    const alpha = overlay.feature.properties?.[opacityProperty];\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n    return color;\n  }\n  return undefined;\n};\n\nconst getStrokeWidth = (\n  prop: GeojsonProps['strokeWidth'],\n  overlay: Overlay,\n) => {\n  if (prop) {\n    return prop;\n  }\n  return overlay.feature.properties?.['stroke-width'];\n};\n\n// GeoJSON.Feature type-guards\nconst isPointFeature = (feature: Feature): feature is Feature<Point> =>\n  feature.geometry.type === 'Point';\n\nconst isMultiPointFeature = (\n  feature: Feature,\n): feature is Feature<MultiPoint> => feature.geometry.type === 'MultiPoint';\n\nconst isAnyPointFeature = (\n  feature: Feature,\n): feature is Feature<Point> | Feature<MultiPoint> =>\n  isPointFeature(feature) || isMultiPointFeature(feature);\n\nconst isLineStringFeature = (\n  feature: Feature,\n): feature is Feature<LineString> => feature.geometry.type === 'LineString';\n\nconst isMultiLineStringFeature = (\n  feature: Feature,\n): feature is Feature<MultiLineString> =>\n  feature.geometry.type === 'MultiLineString';\n\nconst isAnyLineStringFeature = (\n  feature: Feature,\n): feature is Feature<LineString> | Feature<MultiLineString> =>\n  isLineStringFeature(feature) || isMultiLineStringFeature(feature);\n\nconst isPolygonFeature = (feature: Feature): feature is Feature<Polygon> =>\n  feature.geometry.type === 'Polygon';\n\nconst isMultiPolygonFeature = (\n  feature: Feature,\n): feature is Feature<MultiPolygon> => feature.geometry.type === 'MultiPolygon';\n\ntype OverlayPressEvent = {\n  type:\n    | AnyPointOverlay['type']\n    | AnyLineStringOverlay['type']\n    | AnyPolygonOverlay['type'];\n  feature:\n    | AnyPointOverlay['feature']\n    | AnyLineStringOverlay['feature']\n    | AnyPolygonOverlay['feature'];\n  coordinates:\n    | AnyPointOverlay['coordinates']\n    | AnyLineStringOverlay['coordinates']\n    | AnyPolygonOverlay['coordinates'];\n  holes?: AnyPolygonOverlay['holes'];\n};\n\ntype AnyPointOverlay = {\n  type: 'point';\n  feature: Feature<Point | MultiPoint>;\n  coordinates: LatLng;\n};\n\ntype AnyLineStringOverlay = {\n  type: 'polyline';\n  feature: Feature<LineString | MultiLineString>;\n  coordinates: LatLng[];\n};\n\ntype AnyPolygonOverlay = {\n  type: 'polygon';\n  feature: Feature<Polygon | MultiPolygon>;\n  coordinates: LatLng[];\n  holes?: LatLng[][];\n};\n\ntype Overlay = {\n  type: 'point' | 'polyline' | 'polygon';\n  feature: Feature;\n  coordinates: LatLng | LatLng[];\n  holes?: LatLng[][];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}